(()=>{"use strict";var t={630:t=>{t.exports=require("perf_hooks")}},e={};function i(s){var r=e[s];if(void 0!==r)return r.exports;var n=e[s]={exports:{}};return t[s](n,n.exports,i),n.exports}var s={};(()=>{var t=s;Object.defineProperty(t,"__esModule",{value:!0}),t.Query=void 0;const e=i(630);t.Query=class{constructor(t={},e){this._buildmsqlQueries=[],this._buildmsqlOptions=t,this._buildmsqlPoll=e}async poolQuery(t,e){if(void 0===this._buildmsqlPoll)throw Error("pool is undefined");const i=this.proxy(await this._buildmsqlPoll.getConnection());try{return await i.query(t,e)}catch(t){throw t}finally{await i.release()}}async poolQueryStream(t,e){if(void 0===this._buildmsqlPoll)throw Error("pool is undefined");const i=this.proxy(await this._buildmsqlPoll.getConnection());return i.queryStream(t,e).on("end",(async()=>{await i.release()}))}async poolBatch(t,e){if(void 0===this._buildmsqlPoll)throw Error("pool is undefined");const i=this.proxy(await this._buildmsqlPoll.getConnection());try{return await i.batch(t,e)}catch(t){throw t}finally{await i.release()}}async poolInsert(t,e,i){if(void 0===this._buildmsqlPoll)throw Error("pool is undefined");const s=this.proxy(await this._buildmsqlPoll.getConnection());try{return await s.insert(t,e,i)}catch(t){throw t}finally{await s.release()}}async poolUpdate(t,e,i,s){if(void 0===this._buildmsqlPoll)throw Error("pool is undefined");const r=this.proxy(await this._buildmsqlPoll.getConnection());try{return await r.update(t,e,i,s)}catch(t){throw t}finally{await r.release()}}_setConnection(t){this._buildmsqlConnection=t}proxy(t){return this._setConnection(t),new Proxy(t,{get:(t,e,i)=>Reflect.has(this,e)?Reflect.get(this,e,i):Reflect.get(t,e,i)})}async query(t,e){try{this._debugStart(t,e);const i=await this._buildmsqlConnection.query(t,e);return this._buildmsqlMeta=i.hasOwnProperty("meta")?i.meta:i,i}catch(t){throw t}finally{this._debugEnd()}}queryStream(t,e){return this._debugStart(t,e),this._buildmsqlConnection.queryStream(t,e).on("error",(async()=>{this._debugEnd()})).on("fields",(t=>{this._buildmsqlMeta=t})).on("end",(async()=>{this._debugEnd()}))}async batch(t,e){try{this._debugStart(t,e);const i=await this._buildmsqlConnection.batch(t,e);return this._buildmsqlMeta=i,i}catch(t){throw t}finally{this._debugEnd()}}async beginTransaction(){this._buildmsqlOptions.nativeTransactions?await this.query("\nSTART TRANSACTION"):await this._buildmsqlConnection.beginTransaction()}async rollback(){this._buildmsqlOptions.nativeTransactions?await this.query("\nROLLBACK"):await this._buildmsqlConnection.rollback()}async commit(){this._buildmsqlOptions.nativeTransactions?await this.query("\nCOMMIT"):await this._buildmsqlConnection.commit()}getMeta(){return this._buildmsqlMeta}lastInsertId(){return Array.isArray(this._buildmsqlMeta)?void 0:this._buildmsqlMeta.insertId}affectedRows(){return Array.isArray(this._buildmsqlMeta)?void 0:this._buildmsqlMeta.affectedRows}warningStatus(){return Array.isArray(this._buildmsqlMeta)?void 0:this._buildmsqlMeta.warningStatus}quote(t){return this._buildmsqlConnection.escape(t)}async insert(t,e,i){const s=Array.isArray(e);(i=i||{}).returning=!0===i.returning?Object.keys(s?e[0]:e):i.returning,i.duplicate=!0===i.duplicate?Object.keys(s?e[0]:e):i.duplicate,i.chunk=i.chunk||(s?e.length:1);const r=i.replace?"REPLACE":"INSERT",n=i.ignore&&!i.replace?"IGNORE":"",a=Array.isArray(i.returning)&&i.returning.length?`RETURNING ${i.returning.join(", ")}`:"",l=Array.isArray(i.duplicate)&&i.duplicate.length&&!i.replace?`ON DUPLICATE KEY UPDATE ${i.duplicate.map((t=>`${t}=VALUES(${t})`)).join(", ")}`:"",o=`\n            ${r} ${n} ${t} (${s?Object.keys(e[0]).join(", "):Object.keys(e).join(", ")}) \n            VALUES (${s?Object.keys(e[0]).map((t=>`:${t}`)).join(", "):Object.keys(e).map((t=>`:${t}`)).join(", ")}) \n            ${l} \n            ${a};\n        `,u=i.chunk;let d;for(let i=0,r=s?e.length:1;i<r;i+=u){const r=s?e.slice(i,i+u):e;d=u>1?await this.batch({sql:o,namedPlaceholders:!0},r):await this.query({sql:o,namedPlaceholders:!0},r),this._buildmsqlConnection.emit("inserted",t,d)}return d}async update(t,e,i,s){s=s||{};const r=Object.keys(i).map((t=>`${t} = :${t}`)).join(", "),n=`UPDATE ${s.ignore?"IGNORE":""} ${t} SET ${r} WHERE ${e};`,a=await this.query({sql:n,namedPlaceholders:!0},i);return this._buildmsqlConnection.emit("updated",t,a),a}statistics(){return{count:this._buildmsqlQueries.length,time:Math.round(100*this._buildmsqlQueries.reduce(((t,e)=>t+e.time),0))/100,queries:this._buildmsqlQueries}}_debugStart(t,i){if(this._buildmsqlOptions.debug){let s="object"==typeof t?t.sql:t;i&&(Array.isArray(i)?i.map((t=>s=s.replace("?",this.quote(t)))):Object.keys(i).map((t=>s=s.replace(new RegExp(":"+t,"ig"),this.quote(i[t]))))),this._buildmsqlQueries.push({threadId:this._buildmsqlConnection.threadId,start:e.performance.now(),time:0,sql:s})}}_debugEnd(){if(this._buildmsqlOptions.debug){const t=this._buildmsqlQueries.pop();t&&t.start&&(t.time=Math.round(100*(e.performance.now()-t.start))/100,delete t.start,this._buildmsqlQueries.push(t))}}}})(),module.exports=s})();